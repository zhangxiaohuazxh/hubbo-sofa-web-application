package cn.hubbo.apt.annotation.processor

import cn.hubbo.utils.coding.JavaCodeUtils
import cn.hubbo.utils.coding.JavaCodeUtils.Companion.createJavFile
import cn.hubbo.utils.coding.JavaCodeUtils.Companion.generateSourceCode
import cn.hubbo.utils.coding.JavaCodeUtils.Companion.parseSourceCode
import com.google.auto.service.AutoService
import com.google.common.collect.Sets
import com.squareup.javapoet.JavaFile
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import javax.annotation.processing.*
import javax.lang.model.SourceVersion
import javax.lang.model.element.Modifier
import javax.lang.model.element.TypeElement

private val log: Logger = LoggerFactory.getLogger(ForeignFunctionInterfaceBindingProcessor::class.java)

//@AutoService(Processor::class)
//@SupportedAnnotationTypes("cn.hubbo.annotation.FFI")
//@SupportedSourceVersion(SourceVersion.RELEASE_25)
class ForeignFunctionInterfaceBindingProcessor : AbstractProcessor() {

    companion object {

        private const val SUPPORT_ANNOTATION = "cn.hubbo.annotation.FFI"

        private const val GENERATED_COMMENT = "Generated By Hubbo-native-binding"

        private val LIBRARY_CACHE = Sets.newHashSet<String>()

    }

    override fun process(annotations: MutableSet<out TypeElement>, roundEnv: RoundEnvironment): Boolean {
        for (element in annotations) {
            if (element.qualifiedName.contentEquals(SUPPORT_ANNOTATION)) {
                val annotatedElements = roundEnv.getElementsAnnotatedWith(element)
                for (annotatedElement in annotatedElements) {
                    if (annotatedElement.kind.isClass && annotatedElement is TypeElement) {
                        generateSourceCode(annotatedElement, roundEnv)
                    }
                }
            }
        }
        return true
    }

    fun generateSourceCode(
        annotatedElement: TypeElement, roundEnv: RoundEnvironment
    ) {
        // todo 解析该类中的所有native函数，并为该类派生子类，重写其所有的native函数，函数内容为通过FFI调用相同签名的函数
        val sourceStructureInfo = parseSourceCode(
            annotatedElement, roundEnv
        ) {
            it.modifiers.contains(Modifier.PUBLIC) && it.modifiers.contains(Modifier.NATIVE) && !it.modifiers.contains(
                Modifier.STATIC
            )
        }
        log.info("解析到的结果 {}", sourceStructureInfo)
        sourceStructureInfo.apply {
            this.packageName = processingEnv.elementUtils.getPackageOf(annotatedElement).qualifiedName.toString()
        }
        val typeSpec = generateSourceCode(sourceStructureInfo)
        val javFile = createJavFile(sourceStructureInfo)
        javFile.writeTo(processingEnv.filer)
    }


    fun processNativeLibraryName(annotatedElement: TypeElement) {
        // todo 获取注解的value属性 放到 LIBRARY_CACHE 中，并在某个阶段加载动态库
    }


}